#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
from os import path

import argparse
import os
import re
import subprocess
import sys


class Wrapper():
    def __init__(self, argv):
        self.command = argv[0]
        self.args = argv[1:]
        self.ld_path = path.join(path.dirname(__file__), 'ld')
        self.readelf_path = path.join(path.dirname(__file__), 'readelf')
        self.emulation = None
        self.output_file = None
        self.linkFileArgs = []
        self.frameworks_used = []
        self.search_paths = []
        self.options = {}

    def error(self, message):
        print(self.command + ': ' + message)
        sys.exit(1)

    def message(self, message):
        if self.options.verbose:
            print(message)

    def find_framework(self, framework, search_paths):
        result = []
        for search_path in search_paths:
            framework_path = path.join(search_path, '%s.framework' % framework)
            isdir = path.isdir(framework_path)
            if isdir:
                result.append(framework_path)
            self.message('attempt to open ' + framework_path + (' succeeded' if isdir else ' failed'))
        return result

    def readelf(self, filepath):
        proc = subprocess.Popen([self.readelf_path, '-d', filepath], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, _ = proc.communicate()
        if proc.returncode != 0:
            return ([], [])
        libs = re.findall(r'\(NEEDED\)[\w\s:]+\[([^\]]+)\]', output)
        rpaths = re.findall(r'\(RPATH\)[\w\s:]+\[([^\]]+)\]', output)
        rpaths = rpaths[0].split(':') if rpaths else []
        return libs, rpaths

    def load_rpaths(self, filepath):
        libs, rpaths = self.readelf(filepath)
        result = {}
        for rpath in rpaths:
            if rpath.startswith('$ORIGIN') and rpath.endswith('.framework'):
                framework = path.splitext(path.basename(rpath))[0]
                matches = [lib for lib in libs if framework in lib]
                if matches:
                    real_path = path.realpath(rpath.replace('$ORIGIN', path.dirname(filepath)))
                    result[framework] = real_path
        return result

    def get_framework_rpaths(self, framework, framework_paths):
        result = {}
        for framework_path in framework_paths:
            filenames = os.listdir(framework_path)
            filenames = [filename for filename in filenames if framework in filename]
            for filename in filenames:
                result.update(self.load_rpaths(path.join(framework_path, filename)))
        return result

    def invoke_ld(self, args):
        self.message(' "%s" %s' % (self.ld_path, ' '.join(args)))

        proc = subprocess.Popen([self.ld_path] + args)
        proc.communicate()
        if proc.returncode == 0:
            pass
        else:
            sys.exit(proc.returncode)

    def process_args(self, args):
        self.search_paths = [arg[2:] for arg in args if arg.startswith('-L')]

        result = []
        it = iter(args)
        while True:
            try:
                arg = it.next()
                if arg == '-framework':
                    self.process_framework(arg, it, result)
                elif arg == '-filelist':
                    self.process_filelist(arg, it, result)
                else:
                    result.append(arg)
            except StopIteration:
                break

        return result

    def process_framework(self, arg, it, result):
        framework = it.next()
        framework_paths = self.find_framework(framework, self.search_paths)
        if not framework_paths:
            self.error('framework not found ' + framework)
        self.add_framework(framework, framework_paths, result)

    def add_framework(self, framework, framework_paths, result):
        self.frameworks_used.append(framework)
        result.extend(['-L' + framework_path for framework_path in framework_paths])
        result.append('-l' + framework)
        rpaths = self.get_framework_rpaths(framework, framework_paths)
        # Emulate framework re-export
        # Note: also prevents 'error adding symbols: DSO missing from command line' for frameworks,
        # but --copy-dt-needed-entries is preferred (as it will include all libraries)
        for framework, rpath in rpaths.items():
            self.add_framework(framework, [rpath], result)

    def process_filelist(self, arg, it, result):
        filelist = it.next()
        with open(filelist, 'r') as f:
            list = f.read().strip().split('\n')
        fileargs = path.splitext(filelist)[0] + '.LinkFileArgs'
        with open(fileargs, 'w+') as f:
            f.write(' '.join(["'%s'" % filename for filename in list]))
        result.append('@' + fileargs)

    def extend_args(self, args):
        result = list(args)
        if self.options.product_type == 'framework' and self.options.m.startswith('elf'):
            for framework in self.frameworks_used:
                result.append('-rpath=$ORIGIN/../' + framework + '.framework')
            result.append('-soname=' + path.basename(self.options.o))
        return result

    def main(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-o')
        parser.add_argument('-m')
        parser.add_argument('-v', action='store_true', dest='verbose')
        parser.add_argument('--verbose', action='store_true')
        options, _ = parser.parse_known_args(self.args)

        parser = argparse.ArgumentParser()
        parser.add_argument('--product-type')
        wrapper_options, args = parser.parse_known_args(self.args)

        options.__dict__.update(wrapper_options.__dict__)
        self.options = options

        self.message('guestOS ld wrapper (version 1.0)')
        self.message('InstalledDir: ' + path.dirname(__file__))

        args = self.process_args(args)
        args = self.extend_args(args)
        self.invoke_ld(args)


def main():
    Wrapper(sys.argv).main()


if __name__ == '__main__':
    main()
